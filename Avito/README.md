### 1. Расскажи про планировщик, как он работает
[README.md](../go%20runtime%20scheduler/README.md)

#### Ключевые особенности:
Горутин может быть создано десятки тысяч без значительных накладных расходов.

Планировщик прозрачен для разработчика, но его поведение критично для производительности.

Планировщик старается минимизировать переключения контекста и синхронизацию между потоками.

--- 
### Чем занимается рантайм go?
Рантайм Go — это системная библиотека и среда выполнения, реализующая низкоуровневую механику работы языка. Это не просто стандартная библиотека, а критическая часть инфраструктуры, которая управляет выполнением кода.

Основные задачи рантайма Go:
1. Планировщик (Scheduler)
- Управляет жизненным циклом горутин (создание, выполнение, приостановка, уничтожение)
- Распределяет горутины по потокам с помощью модели G-M-P
- Обеспечивает вытеснение (preemption), балансировку нагрузки (work stealing)

2. Сборщик мусора (Garbage Collector)
- Автоматически освобождает неиспользуемую память
- Инкрементальный, параллельный, триединофазный: mark - sweep - stop-the-world
- Обеспечивает мягкую паузу и предсказуемую латентность

3. Работа с памятью
- Выделение и освобождение памяти (heap, stack)
- Управление размером стека горутин (автоматическое увеличение и уменьшение)
- Арендная модель mcache, mcentral, mheap — для быстрого выделения

4. Системные вызовы и блокировки
- Асинхронное выполнение системных вызовов, чтобы не блокировать потоки
- Управление вызовами syscall, cgo и взаимодействием с ОС

5. Отладка и профилирование
- Поддержка runtime/pprof, трассировка, трейсинг, метрики
- Реализация стек-трейсов, дампов и диагностических интерфейсов

6. Рефлексия и типовая информация
- Хранение информации о типах и структурах
- Обеспечение работы пакета reflect и interface{}

7. Паники и восстановление
- Реализация panic, recover, defer
- Устойчивое завершение исполнения в случае ошибок

8. Инициализация программы
- Вызов init-функций
- Настройка среды выполнения перед main()

Вывод:
runtime — это фундаментальная часть Go, обеспечивающая автоматическое управление параллелизмом, памятью и выполнением кода. Без него невозможна работа горутин, сборщика мусора, системных вызовов и других высокоуровневых возможностей языка.

---
### За счет чего go позволяет работать с большим колличеством соединений
Go позволяет работать с большим количеством соединений за счёт следующих ключевых механизмов:

1. Горутины (goroutines)
- Легковесные: требуют ~2–4 КБ начального стека, растущего по мере необходимости.
- Могут масштабироваться до миллионов экземпляров без существенных накладных расходов.
- Планировщик Go автоматически распределяет горутины между потоками ОС, эффективно используя многопроцессорные системы.

2. Неблокирующее выполнение I/O
- Большинство операций ввода-вывода в Go (например, net.Conn.Read, Write) реализованы через асинхронный I/O внутри рантайма.
- Используется epoll (Linux), kqueue (BSD, macOS), IOCP (Windows) — в зависимости от ОС.
- Рантайм Go сам регистрирует файловые дескрипторы и блокирует горутину, но не поток ОС — это позволяет другим горутинам продолжать выполнение.

3. Модель CSP (Communicating Sequential Processes)
- Каналы (chan) и select позволяют координировать конкурентные операции без явных блокировок и mutex'ов.
- Снижается сложность при построении высоконагруженных сетевых приложений.

4. Простая модель памяти и автоматическое управление
- Автоматический сборщик мусора минимизирует утечки памяти при работе с большим числом соединений.
- Нет ручного управления потоками или дескрипторами — снижается сложность и вероятность ошибок.

5. Пакет netpoll в рантайме
- Отвечает за интеграцию с системными механизмами неблокирующего I/O.
- Обеспечивает масштабируемую обработку тысяч соединений на одном или нескольких потоках.
#### Вывод:
Go масштабируется до сотен тысяч или миллионов соединений за счёт собственных горутин, неблокирующего ввода-вывода через системные интерфейсы и встроенного планировщика, который эффективно использует ресурсы без участия разработчика.

---
### Что такое каналы, зачем они нужны
[README.md](../channel/README.md)

---
### Какие знаешь примитивы синхронизации
[README.md](../sync%20go/README.md)

---
### Что такое интерфейс
[README.md](../interface/README.md)

---
### В чем отличие слайсов от мап
    Мапа
    https://github.com/Jafar05/interview-go/tree/main/map

    Слайсы
    https://github.com/Jafar05/interview-go/tree/main/slice

    Массивы 
    https://github.com/Jafar05/interview-go/tree/main/array

---
### Как происходит сборка мусора
Что будет когда мы в коде просим выделить память, как это выглядит с точки зрения операционной системы и что она будет делать.

[README.md](https://github.com/Jafar05/interview-go/blob/main/common/README.md#что-будет-когда-мы-в-коде-просим-выделить-память-как-это-выглядит-с-точки-зрения-операционной-системы-и-что-она-будет-делать)

    
Сборщик мусора

// TODO: 

---
### Тесты
Какие бывают

Полезные команды

Что такое моки

--

Сталкивался ли с профилированием программ 

Для чего нужно