### Если бы ты строил с нуля проект, то какую БД ты бы выбрал и почему? Какие плюсы и минусы есть

Если я начинаю проект с нуля и у меня нет жёстких ограничений на тип БД, я бы в большинстве случаев выбрал PostgreSQL как основной источник данных.

#### Почему именно Postgres:

- Зрелость и стабильность — десятилетия разработки, проверена на высоких нагрузках.
- ACID-гарантии** — строгая консистентность, транзакции, надёжная работа с критичными данными.
- Расширяемость — JSONB для полуструктурированных данных, геоданные через PostGIS, full-text search.
- Поддержка сложных запросов — оконные функции, CTE, богатый SQL.
- Сообщество и экосистема — инструменты для бэкапов, репликации, мониторинга.
- Вертикальное и горизонтальное масштабирование — можно начать с одной ноды, а потом перейти к репликации, шардированию.

#### Минусы PostgreSQL:
- Масштабирование по горизонтали сложнее, чем в некоторых NoSQL (например, Cassandra).
- Не лучшая производительность для write-heavy сценариев с миллионами RPS.
- JSONB гибкий, но не такой быстрый, как нативный движок NoSQL.

#### Почему не NoSQL (MongoDB, Cassandra, Redis) как основную БД в старте:
- MongoDB удобна для прототипов и гибких схем, но без строгих ACID-гарантий на уровне всей коллекции — выше риск несогласованности данных.
- Cassandra отлично масштабируется, но сложнее в настройке и требует иной модели мышления.
- Redis великолепен как in-memory кэш или fast-store, но не как primary source of truth.

#### Подход:
- Начал бы с PostgreSQL, но спроектировал архитектуру так, чтобы можно было выделить отдельные части в специализированные хранилища: Redis для кэша, ClickHouse для аналитики, Elasticsearch для поиска.

Таким образом, я бы обеспечил баланс между надёжностью, гибкостью и возможностью масштабирования, не закрывая себе пути для дальнейшего развития архитектуры.

### В каких случаях можно выбирать не реляционные бд?

Я рассматриваю NoSQL, когда требования проекта выходят за пределы классических сильных сторон реляционных СУБД.
Основные случаи:

1. Очень большие объёмы данных + горизонтальное масштабирование

   - Когда данные растут терабайтами/петабайтами, и вертикальное масштабирование PostgreSQL или MySQL становится дорогим и неэффективным.
   - Пример: Cassandra, MongoDB с шардингом.
   - Сценарий: телеметрия IoT, логирование в реальном времени.

2. Нужна гибкая схема (schema-less)
   - Когда структура данных меняется часто или заранее неизвестна.
   - Пример: MongoDB (JSON-документы), Couchbase.
   - Сценарий: быстрое прототипирование, хранение пользовательских профилей с сильно разнящимися атрибутами.

3. Временные ряды (time-series)
   - Данные приходят в виде событий с временной меткой, нужны оптимизация на insert и агрегации по времени.
   - Пример: InfluxDB, TimescaleDB (хотя Timescale — надстройка над Postgres).
   - Сценарий: метрики серверов, финансовые котировки.

4. Графовые связи
   - Когда важно моделировать и быстро обходить сложные взаимосвязи между объектами.
   - Пример: Neo4j, JanusGraph.
   - Сценарий: социальные сети, рекомендательные системы.

5. Сверхбыстрый доступ к ключам (key-value store)
   - Когда нужно очень быстро читать/писать по ключу без сложных запросов.
   - Пример: Redis, Aerospike.
   - Сценарий: кэш сессий, счётчики, очереди задач.

6. Event sourcing / append-only
   - Когда данные в основном добавляются, а не обновляются.
   - Пример: Kafka (лог-система), Cassandra (write-оптимизирована).
   - Сценарий: аудит логов, журнал транзакций.

Компромиссы при выборе NoSQL:
- Нет или ограниченная поддержка ACID (хотя есть исключения, например Mongo 4+ на уровне документа).
- Более сложные транзакции, если нужны операции над несколькими сущностями.
- Не всегда подходит для сложных запросов и агрегаций.

**Итог:** NoSQL я выбираю там, где есть жёсткие требования по масштабированию, гибкой схеме или специфичной модели данных, а строгие ACID-транзакции на уровне всей системы не критичны.