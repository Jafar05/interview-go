package two_pointers

func IsOneEditDistance(s string, t string) bool {
	// Получаем длины строк
	m, n := len(s), len(t)

	// Если s короче t, меняем их местами, чтобы s всегда была длиннее или равна t.
	// Это упрощает логику: теперь нужно проверять только удаление из s или замену, но не добавление.
	if m < n {
		return IsOneEditDistance(t, s)
	}

	// Если разница в длине больше 1, строки точно не на расстоянии одной операции.
	// Пример: s = "abc", t = "a" → разница 2 → false.
	if m-n > 1 {
		return false
	}

	// Проходим по каждому символу строки t (так как len(t) ≤ len(s))
	for i := range t {
		// Если нашли совпадение символов пропкскаем:
		if s[i] == t[i] {
			continue
		}

		if m == n {
			// Если длины равны → возможна замена символа.
			// Проверяем, совпадают ли остатки строк после этого символа.
			// Пример: s = "abc", t = "adc" → после 'b' и 'd' проверяем "c" == "c" → true.
			return s[i+1:] == t[i+1:]
		} else {
			// Если s длиннее t на 1 → возможна вставка в s или удаление из t.
			// Проверяем, совпадает ли хвост s (пропуская текущий символ) с хвостом t.
			// Пример: s = "abxc", t = "abc" → после 'x' и 'c' проверяем "c" == "c" → true.
			return s[i+1:] == t[i:]
		}
	}

	// Если несовпадений не было, но s длиннее t на 1 → значит, лишний символ в конце s.
	// Пример: s = "abcd", t = "abc" → все символы t совпали, но s длиннее → true.
	// Если длины равны → строки идентичны → false (нужна ровно одна правка).
	return m == n+1
}
