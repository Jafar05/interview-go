В Go массивы — это фиксированные структуры данных, которые содержат несколько элементов одного типа. Знание массивов важно для собеседований, так как это основа работы с последовательными данными. Вот основные моменты, которые стоит знать:

## 1. Объявление массива
   Массив в Go всегда имеет фиксированную длину, которая указывается при его создании.

#### Пример:

```go
var arr [5]int // массив из 5 элементов типа int
```
Можно также инициализировать массив с заданными значениями:

```go
arr := [3]int{1, 2, 3}
```
В этом примере создается массив из 3 элементов типа int с указанными значениями.

## 2. Доступ к элементам массива
   Элементы массива индексируются, начиная с нуля. Для доступа к элементу массива используется индекс в квадратных скобках.

#### Пример:
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[0]) // выводит 1
arr[1] = 10        // изменяет второй элемент массива
fmt.Println(arr[1]) // выводит 10
```

## 3. Размер массива
   Размер массива фиксируется на момент его создания и не может быть изменен в дальнейшем. Его можно узнать через встроенную функцию len().

#### Пример:
```go
arr := [4]int{1, 2, 3, 4}
fmt.Println(len(arr)) // выводит 4
```

## 4. Массивы и копирование
   Когда вы присваиваете один массив другому, происходит копирование всех элементов. Это отличается от срезов (slice), где передается ссылка на исходные данные.

#### Пример:
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1 // копия массива
arr2[0] = 10

fmt.Println(arr1) // выводит [1, 2, 3]
fmt.Println(arr2) // выводит [10, 2, 3]
```
## 5. Использование массива с фиксированным размером
   Массивы в Go часто не используются напрямую, потому что их размер зафиксирован, и если нужно работать с последовательностями данных переменной длины, используют срезы. Но знание работы с массивами важно, так как срезы строятся на их основе.

## 6. Массивы как параметры функции
   Массивы передаются в функцию по значению. Это означает, что если вы передаете массив в функцию, копируются все элементы.

#### Пример:
```go
func printArray(arr [3]int) {
    fmt.Println(arr)
}

arr := [3]int{1, 2, 3}
printArray(arr) // передаем массив в функцию
```
# 7. Массивы и многомерные массивы
   Массивы в Go могут быть многомерными. Важно помнить, что каждый размер в многомерном массиве указывается отдельно.

#### Пример:

```go
var arr [2][3]int // двумерный массив 2x3
arr[0][0] = 1
arr[1][2] = 5
fmt.Println(arr) // выводит [[1 0 0] [0 0 5]]
```

## 8. Массивы в Go и производительность
   Хотя массивы фиксированы по размеру, они обеспечивают хорошую производительность для небольших данных. Однако, если размер данных может изменяться, обычно используют срезы (slice), которые более гибкие.

## 9. Различие между массивами и срезами
   - Массив — это фиксированный размер, и его длина не может изменяться.
   - Срез — это более гибкая структура, которая основана на массиве, но позволяет изменять размер.

#### Пример среза:

```go
arr := [3]int{1, 2, 3}
slice := arr[:] // срез от массива
fmt.Println(slice) // выводит [1 2 3]
```

# 10. Вывод на собеседованиях

- Зачастую на собеседовании вам могут задать вопросы о различиях между массивами и срезами, как передаются массивы в функции, как работает копирование данных.
- Могут попросить реализовать алгоритм, использующий массивы, например, сортировку, или найти максимальный/минимальный элемент.
- Важно отметить, что в Go рекомендуется использовать срезы, а не массивы, из-за их гибкости.

### Резюме для собеседования:

- Массивы в Go имеют фиксированный размер.
- Массивы передаются по значению (копируются).
- Для работы с динамическими данными лучше использовать срезы.
- Массивы могут быть многомерными.

---

### zero value
- Zero value: массив из значений по умолчанию для его элементов.
- Например, для массива типа []int элементы будут равны 0, для массива типа []bool — false, для []string — пустая строка.
#### Пример:
```go
var a [3]int
fmt.Println(a) // [0 0 0]
```
