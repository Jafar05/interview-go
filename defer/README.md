В Go defer — это ключевое слово, которое используется для отложенного выполнения функции. Когда функция встречает defer, она планирует выполнение указанного кода после завершения работы текущей функции, но до её выхода.

### Основные характеристики defer:
1. Выполняется перед выходом из функции.
2. Несколько defer выполняются в обратном порядке (стек).
3. Полезен для управления ресурсами, такими как закрытие файлов, разблокировка мьютексов или освобождение сетевых соединений.

#### Пример 1: Отложенный вызов функции
```go
package main

import "fmt"

func main() {
    fmt.Println("Начало")
    defer fmt.Println("Это будет выполнено последним")
    fmt.Println("Середина")
}
```
#### Результат:
```go
Начало
Середина
Это будет выполнено последним
```

#### Пример 2: Несколько defer

Если в функции есть несколько defer, они выполняются в обратном порядке их объявления:

```go
package main

import "fmt"

func main() {
    defer fmt.Println("Первый")
    defer fmt.Println("Второй")
    defer fmt.Println("Третий")
}
```
#### Результат:
```go
Третий
Второй
Первый
```

### Пример 3: Управление ресурсами
defer особенно полезен для освобождения ресурсов, например, закрытия файла:

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    defer file.Close() // файл будет закрыт перед выходом из функции
    fmt.Println("Файл открыт:", file.Name())
}
```
**Преимущество:** Мы гарантируем, что файл закроется, даже если в функции произойдет ошибка.

### Пример 4: Изменение значения переменной
При использовании **defer** параметры функции фиксируются **в момент объявления defer:**

```go
package main

import "fmt"

func main() {
    x := 10
    defer fmt.Println("Значение x:", x) // значение `x` фиксируется здесь
    x = 20
    fmt.Println("Обновленное значение x:", x)
}
```
#### Результат:
```yaml
Обновленное значение x: 20
Значение x: 10
```

### Пример 5: Вложенные defer
Если используется panic, отложенные вызовы все равно выполняются:

```go
package main

import "fmt"

func main() {
    defer fmt.Println("Выполнится даже при панике")
    panic("Ошибка")
}
```
#### Результат:
```go
Выполнится даже при панике
panic: Ошибка
```

### Где использовать defer:
1. Закрытие файлов, сетевых соединений, баз данных.
```go
file, _ := os.Open("file.txt")
defer file.Close()
```
2. Разблокировка мьютексов:
```go
mutex.Lock()
defer mutex.Unlock()
```
3. Освобождение памяти в C-библиотеках:
```go
C.free(pointer)
defer C.free(pointer)
```
4. Логирование (например, вход и выход из функции):
```go
defer fmt.Println("Выход из функции")
```