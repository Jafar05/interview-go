**Планировщик** в Go — это компонент рантайма, который управляет выполнением горутин на доступных системных потоках (OS threads). Он предназначен для эффективного использования ресурсов процессора, упрощая многопоточную разработку.

### Основные задачи планировщика:
1. Планирование горутин:
- Горутин может быть огромное количество, но планировщик распределяет их выполнение между ограниченным числом системных потоков.
- Планировщик использует модель M:N, где M — это количество горутин, а N — количество потоков ОС.

2. Обеспечение конкурентности:
- Выполняет горутины параллельно (если есть несколько процессоров) или псевдопараллельно (на одном процессоре).
  На одном ядре горутины не выполняются физически параллельно. Они выполняются псевдопараллельно: планировщик Go выделяет каждой горутине небольшой квант времени и переключается между ними. Это создаёт эффект конкурентности — мы можем запускать десятки тысяч горутин и все они будут прогрессировать, даже на одном ядре

3. Переключение контекста:
- Планировщик решает, какая горутина должна выполняться дальше, и переключает контекст между ними, минимизируя накладные расходы.

### Как работает планировщик:
1. Goroutine (G): Представляет горутину, то есть легковесный поток.
2. Machine (M): Отражает системный поток, на котором выполняются горутины.
3. Processor (P): Логический процессор, который управляет очередью готовых горутин и распределяет их на потоки.

- G выполняется на M, используя P.
- Каждая P имеет очередь готовых горутин.
- Планировщик использует work stealing: если у одной P закончились задачи, она может "украсть" горутины из другой.
   - Сначала берёт из своей локальной очереди (P.runq).
   - Если там пусто — пытается украсть горутины из локальной очереди другого P (work stealing).
   - Если и это не удалось — обращается к глобальной очереди.
   - То есть приоритет:
     - **своя локальная → чужая локальная → глобальная.**

### Почему это важно:
Планировщик Go позволяет эффективно использовать ресурсы процессора, управляя большими объемами конкурирующих задач с минимальными затратами, и избавляет разработчиков от необходимости вручную управлять потоками.