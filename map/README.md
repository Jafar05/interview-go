# В этом разделе я расскажу о map в Go, хеш-таблицах и хеш-функциях, а также объясню концепцию high-order и low-order битов, их влияние на работу с хеш-функциями и хеш-таблицами.

## 1. Что такое map в Go?
   В Go, тип map представляет собой коллекцию пар ключ-значение, где каждый ключ связан с конкретным значением. Это аналог ассоциативных массивов или хеш-таблиц, которые существуют в других языках программирования.

#### Пример объявления и использования мапы:

```go
package main

import "fmt"

func main() {
	// Создание мапы с ключами типа string и значениями типа int
	m := map[string]int{
		"apple":  5,
		"banana": 3,
		"cherry": 7,
	}

	// Доступ к элементам по ключу
	fmt.Println(m["apple"])  // Вывод: 5
	fmt.Println(m["banana"]) // Вывод: 3

	// Добавление нового элемента
	m["orange"] = 8

	// Удаление элемента
	delete(m, "banana")

	// Проверка на наличие ключа
	value, exists := m["banana"]
	fmt.Println(value, exists) // Вывод: 0 false (значение 0 и false, т.к. элемента нет)
}
```
### Особенности мап в Go:
- Неупорядоченность: Порядок итерации по мапе случайный, так как мапа основана на хеш-таблице.
- Динамическое изменение размера: Мапа может увеличивать свой размер по мере добавления новых элементов.
- Гарантированно уникальные ключи: В мапе не может быть двух одинаковых ключей. Если вы пытаетесь добавить элемент с уже существующим ключом, его значение будет перезаписано.

## В Go есть два основных способа работать с мапами: инициализированные и неинициализированные мапы. Разница между ними важна, поскольку она влияет на то, как можно работать с мапами, как их создавать и какие ошибки могут возникнуть.

### 1. Неинициализированная мапа (nil map)
Если вы создаете мапу с помощью var, она по умолчанию будет неинициализированной (nil). Она не будет указывать на никакой объект в памяти, и попытка вставить элементы в такую мапы приведет к панике, а получение значения возвратит zero value

#### Пример:
```go
package main

import "fmt"

func main() {
    var m map[string]int // Неинициализированная мапа (nil)
	
    fmt.Println(m["apple"]) // Возвратит zero value Значения мапы
	
    // Попытка вставить элемент в неинициализированную мапу
    // Это приведет к панике!
    // m["apple"] = 5  // Паника: assignment to entry in nil map

    fmt.Println(m) // Выводит: map[]
}
```
#### Почему это так? Мапа по умолчанию инициализируется значением nil. В этом состоянии она не указывает на реальный объект хеш-таблицы, и операции с такой мапой (например, добавление элементов) невозможны.

### 2. Инициализированная мапа (с помощью make или литерала)
Чтобы работать с мапой безопасно, нужно либо использовать make, либо литерал мапы. Это создаст мапу в памяти, и вы сможете безопасно выполнять операции с элементами.

#### Инициализация с помощью make:
```go
package main

import "fmt"

func main() {
// Инициализация с помощью make
m := make(map[string]int)  // Инициализированная мапа

    m["apple"] = 5 // Безопасно добавляем элемент
    fmt.Println(m)  // Выводит: map[apple:5]
}
```
#### Инициализация с помощью литерала мапы:
```go
package main

import "fmt"

func main() {
// Инициализация с помощью литерала мапы
m := map[string]int{
"apple": 5,
"banana": 10,
}

    fmt.Println(m) // Выводит: map[apple:5 banana:10]
}
```
В обоих случаях мапа будет корректно инициализирована, и вы сможете безопасно работать с ней.

### 3. Особенности работы с мапами
1. Инициализированная мапа (с помощью make или литерала):
- После инициализации мапы с помощью make, вы можете безопасно добавлять, удалять и изменять элементы. Мапа будет указывать на реальный объект хеш-таблицы в памяти.

2. Неинициализированная мапа (nil map):
- Мапа в этом случае не указывает на память, и любые попытки записать в неё данные приведут к панике. Чтение значений из неинициализированной мапы не вызовет панику, но вернется нулевое значение для данного типа (например, для чисел это 0, для строк — пустая строка, для указателей — nil).

#### Пример чтения из неинициализированной мапы:
```go
package main

import "fmt"

func main() {
var m map[string]int // Неинициализированная мапа (nil)

    // Чтение из неинициализированной мапы
    // Это не приведет к панике, но вернет нулевое значение (0)
    fmt.Println(m["apple"]) // Выводит: 0

    // Проверка на наличие ключа
    value, exists := m["apple"]
    fmt.Println(value, exists) // Выводит: 0 false
}
```

## 4. Что происходит при записи в неинициализированную мапу?
Как уже упоминалось, попытка записать в неинициализированную мапу вызовет паніку. Но что если нужно создавать мапу в поздний момент (например, внутри функции), но не инициализировать её сразу?

#### Решение:
всегда используйте make для инициализации мапы или создавайте её с помощью литерала в момент создания. Это обеспечит корректную работу с мапой, избегая паники.

## 5. Резюме: как работать с мапами в Go
### Неинициализированная мапа (nil):

Не может быть использована для добавления или изменения элементов.
Чтение элементов вернет значение по умолчанию для типа (например, 0 для чисел).
Попытка записи вызовет панику.
Инициализированная мапа:

С помощью make или литерала можно создать мапу, с которой можно безопасно работать.
Все операции записи, удаления и поиска выполняются корректно.

### Рекомендация:
Чтобы избежать паники и ошибок, всегда инициализируйте мапы перед их использованием:

```
go
m := make(map[string]int)  // Инициализированная мапа
m["apple"] = 5             // Безопасная запись
```

#### Или используйте литерал:
```
go
m := map[string]int{"apple": 5, "banana": 10}
```

#### Итак, основное правило: никогда не пытайтесь изменять или добавлять элементы в неинициализированную мапу.

---

### В Go нулевое значение для мапы — это nil. Это значит, что если мапа не была инициализирована, то она не указывает на реальный объект в памяти. Однако при чтении из неинициализированной мапы возвращается нулевое значение для типа значений (например, 0 для чисел, "" для строк и nil для указателей).

#### Основные моменты:
- Чтение из nil мапы не вызывает паники, но возвращает нулевое значение.
- Запись в nil мапу вызывает панику.
- При проверке наличия ключа в nil мапе результат будет false, а значение — нулевое для этого типа.

#### Пример:

```
go
var m map[string]int // nil map
fmt.Println(m["key"]) // 0 (нулевое значение для int)

m["key"] = 1 // panic: assignment to entry in nil map
```

---

## zero value
- Zero value: nil
- Мапы — это ссылочные типы, и их zero value — это nil, что означает отсутствие мапы, но можно безопасно проверять на наличие ключей.
  Пример:

```go
var m map[string]int
fmt.Println(m) // nil
```

---

## 2. Что такое Хеш-таблица?
   Хеш-таблица — это структура данных, которая используется для эффективного хранения пар "ключ-значение" с быстрым доступом к значениям по ключу.

#### Принцип работы хеш-таблицы:
- Хеш-функция — это функция, которая принимает ключ и возвращает индекс (или хеш) в массиве (или таблице), где будет храниться соответствующее значение.
- Коллизии — случаются, когда два разных ключа хешируются в одинаковое значение. В хеш-таблицах с разрешением коллизий могут использоваться разные методы, такие как:
1. Цепочки (Chaining): Каждый элемент с одинаковым хешом хранится в списке (или другой структуре данных) в том же индексе.
2. Открытая адресация (Open Addressing): Если два ключа хешируются в один индекс, то поиск "пустого" места для второго элемента будет происходить в другом месте таблицы.
#### Пример работы хеш-таблицы:
- Применяется хеш-функция к ключу, чтобы получить индекс.
- Если в этом индексе уже есть элемент (коллизия), то решается, как с ней поступить (например, добавляется в цепочку или используется открытая адресация).
- При запросе значения по ключу снова используется хеш-функция для вычисления индекса и поиска значения.
- Пример хеш-таблицы в Go можно увидеть через тип map, который работает как хеш-таблица.

### Бакеты в мапах и когда происходит эвакуация
#### 1. Про бакеты в мапах:
- Бакеты — это структуры, в которых хранятся ключи и значения мапы. Каждый бакет содержит фиксированное количество пар ключ-значение.
- Хэш-функция определяет, в какой бакет попадет ключ.
- Если в бакете есть коллизии (несколько ключей с одинаковым хэшом), они хранятся в виде цепочек внутри бакета.

#### 2. Когда происходит эвакуация:
**Эвакуация** — это процесс перемещения данных из старых бакетов в новые. Она происходит во время **расширения (resize)** мапы:
- При эвакуации в новый бакет переносятся все элементы старого бакета, включая данные из основного бакета и его оверфлоу. Хэш-функция пересчитывается, и элементы распределяются по новому набору бакетов, так как их количество увеличилось.
#### Причина расширения:
- Если мапа достигает определенного коэффициента загрузки (например, слишком много элементов на бакет).
- В случае удаления большого количества элементов мапа также может уменьшиться.

#### Процесс эвакуации:
- При увеличении размера мапы количество бакетов удваивается.
- Данные из старых бакетов перераспределяются между новыми бакетами на основе нового хэш-функционирования.

#### При скольки элементов на бакет происходит эвакуация?

**Эвакуация** (перераспределение) бакетов в мапах Go происходит, когда **коэффициент загрузки** превышает определенный порог.

#### Конкретные числа:
1. Максимум 8 элементов на бакет:
- Если в одном бакете становится больше 8 элементов (включая ключи из основной структуры и оверфлоу-бакетов), запускается процесс увеличения числа бакетов.

2. Оверфлоу-бакеты:
- Если бакет переполняется (например, в результате коллизий), создаются дополнительные "оверфлоу-бакеты".
- Если общее количество элементов на один бакет, включая оверфлоу, превышает порог в 8 элементов, это сигнал для перераспределения.

#### Почему 8?
- Это значение выбрано как компромисс между производительностью и использованием памяти. Слишком большая загрузка бакета замедляет операции поиска, а слишком маленькая увеличивает затраты на память.
  Таким образом, если количество элементов на бакет превышает 8, мапа начинает процесс эвакуации и удваивает количество бакетов.

---

## 3. Что такое хеш-функция?
   Хеш-функция — это функция, которая преобразует входные данные (например, строку или число) в фиксированный размер, обычно целое число. Это число называется хешем, и оно используется для размещения данных в хеш-таблице.

#### Хеш-функции имеют несколько ключевых свойств:

- Детерминированность: Для одного и того же входного значения хеш-функция всегда должна возвращать одинаковый результат.
- Быстродействие: Хеш-функция должна работать быстро, особенно при большом количестве данных.
- Распределённость: Хеш-функция должна обеспечивать равномерное распределение хешей по всей таблице, чтобы минимизировать коллизии.

#### Пример хеш-функции (простейший вариант):

```go
package main

import "fmt"

func simpleHash(key string) int {
	hash := 0
	for i := 0; i < len(key); i++ {
		hash += int(key[i])
	}
	return hash
}

func main() {
	key := "apple"
	fmt.Println(simpleHash(key))  // Выводит хеш-значение для строки "apple"
}
```
#### В реальных хеш-таблицах обычно используются более сложные хеш-функции, такие как:

- SHA-256 (используется в криптографии),
- FNV-1a (быстрая и простая хеш-функция для строк),
- MurmurHash (популярная хеш-функция для хеш-таблиц).

---

## 4. High-order и Low-order биты в хеш-функциях
### Давай разберем High-order (старшие) и Low-order (младшие) биты в хэш-функциях на примере работы хэш-таблицы в Go.

### Основы: что такое биты?
- Биты — это 0 и 1, из которых состоят данные в памяти компьютера.
- Если представить число в двоичном виде, то:
- - Младшие биты — это биты ближе к правой стороне (например, последние несколько).
- - Старшие биты — это биты ближе к левой стороне (например, первые несколько).
Например, для числа 10101100:
- Младшие биты — 1100 (правые 4 бита).
- Старшие биты — 1010 (левые 4 бита).
### Как это связано с map в Go?
1. **map в Go** использует хэш-функцию для того, чтобы быстро находить данные. Хэш-функция превращает ключ (например, строку или число) в некое двоичное число (хэш).
2. Это двоичное число делится на **buckets** (корзины), где хранятся данные. Какому bucket'у будет соответствовать ключ, зависит от битов хэша.
3. **Младшие биты** часто используются для определения индекса корзины. Например, если у тебя 8 корзин, Go может использовать последние 3 бита хэша (так как 2³ = 8):

```plaintext
Хэш: 10101100
Младшие 3 бита: 100 → корзина номер 4.
```
3. Однако, если корзин становится больше, Go начинает использовать не только младшие биты, но и старшие биты, чтобы равномерно распределять данные. Это помогает избежать ситуации, когда все данные попадают только в несколько корзин.

### Почему важны High-order и Low-order биты?
- Low-order биты: Используются для распределения по корзинам, когда их мало (начальные этапы работы map).
- High-order биты: Важны, когда нужно добавить больше корзин. Если использовать только младшие биты, данные могут распределяться неравномерно (кластеризация).
#### Пример с реальным хэшем
Если представить, что хэш-функция дала нам хэш 10101100, и у нас:

- 8 корзин (3 младших бита):

```plaintext
Хэш: 10101100
Используем младшие 3 бита: 100 → корзина номер 4.
```
- 16 корзин (4 младших бита):
```plaintext
Хэш: 10101100
Используем младшие 4 бита: 1100 → корзина номер 12.
```
Когда map расширяется (например, с 8 до 16 корзин), Go начинает учитывать больше битов хэша, включая старшие, чтобы данные распределялись равномерно.

### Итог:
- Младшие биты (Low-order): Сначала определяют, в какую корзину попадет ключ.
- Старшие биты (High-order): Используются, когда корзин становится больше, чтобы данные равномерно распределялись.
---

## 5. Как работает мапа в Go "под капотом"?
   Хеширование ключа: Каждый ключ, который вы добавляете в мапу, проходит через хеш-функцию, которая вычисляет хеш-значение. Это хеш-значение определяет индекс в массиве (или бакете), где будет храниться соответствующее значение.

### Коллизии:
Когда два разных ключа хешируются в одинаковое значение (коллизия), Go использует цепочку для хранения значений с одинаковым хешем в одном бакете. То есть для одного индекса будет храниться список значений с разными ключами.

### Балансировка:
Когда мапа заполняется, Go автоматически расширяет таблицу и перераспределяет элементы, чтобы сохранить эффективность операций вставки, удаления и поиска. Это помогает избежать "переполнения" таблицы.

### Производительность:
Хеш-таблица в Go предоставляет среднее время выполнения операций:

#### Поиск: O(1) в среднем.
#### Вставка: O(1) в среднем.
#### Удаление: O(1) в среднем. Однако в случае частых коллизий или плохой хеш-функции время работы может увеличиться.
#### O(1) - Так же называется константное
