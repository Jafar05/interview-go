# В этом разделе я расскажу о map в Go, хеш-таблицах и хеш-функциях, а также объясню концепцию high-order и low-order битов, их влияние на работу с хеш-функциями и хеш-таблицами.

## 1. Что такое map в Go?
   В Go, тип map представляет собой коллекцию пар ключ-значение, где каждый ключ связан с конкретным значением. Это аналог ассоциативных массивов или хеш-таблиц, которые существуют в других языках программирования.

#### Пример объявления и использования мапы:

```go
package main

import "fmt"

func main() {
	// Создание мапы с ключами типа string и значениями типа int
	m := map[string]int{
		"apple":  5,
		"banana": 3,
		"cherry": 7,
	}

	// Доступ к элементам по ключу
	fmt.Println(m["apple"])  // Вывод: 5
	fmt.Println(m["banana"]) // Вывод: 3

	// Добавление нового элемента
	m["orange"] = 8

	// Удаление элемента
	delete(m, "banana")

	// Проверка на наличие ключа
	value, exists := m["banana"]
	fmt.Println(value, exists) // Вывод: 0 false (значение 0 и false, т.к. элемента нет)
}
```
### Особенности мап в Go:
- Неупорядоченность: Порядок итерации по мапе случайный, так как мапа основана на хеш-таблице.
- Динамическое изменение размера: Мапа может увеличивать свой размер по мере добавления новых элементов.
- Гарантированно уникальные ключи: В мапе не может быть двух одинаковых ключей. Если вы пытаетесь добавить элемент с уже существующим ключом, его значение будет перезаписано.
- Ключами в мапе могут быть только сравниваемые(compared) типы:
  1. числа
  2. строки
  3. булевые значения
  4. указатели
  5. константные массивы
  6. Структуры как ключи
     - Если структура состоит только из сравнимых полей (например, числа, строки, массивы), её тоже можно использовать как ключ.
- Не потокобезопасна

## В Go есть два основных способа работать с мапами: инициализированные и неинициализированные мапы. Разница между ними важна, поскольку она влияет на то, как можно работать с мапами, как их создавать и какие ошибки могут возникнуть.

### 1. Неинициализированная мапа (nil map)
Если вы создаете мапу с помощью var, она по умолчанию будет неинициализированной (nil). Она не будет указывать на никакой объект в памяти, и попытка вставить элементы в такую мапы приведет к панике, а получение значения возвратит zero value

#### Пример:
```go
package main

import "fmt"

func main() {
	// Объявляем переменную мапы, но не инициализируем ее
    var m map[string]int // Неинициализированная мапа (nil)
	
    fmt.Println(m["apple"]) // Возвратит zero value Значения мапы
	
    // Попытка вставить элемент в неинициализированную мапу
    // Это приведет к панике!
    // m["apple"] = 5  // Паника: assignment to entry in nil map

    fmt.Println(m) // Выводит: map[]

	// Попытка записи в неинициализированную (nil) мапу
	m["key"] = 42 // Здесь произойдет runtime panic: "assignment to entry in nil map"
}
```
#### Почему это так? Мапа по умолчанию инициализируется значением nil. В этом состоянии она не указывает на реальный объект хеш-таблицы, и операции с такой мапой (например, добавление элементов) невозможны.

### 2. Инициализированная мапа (с помощью make или литерала)
Чтобы работать с мапой безопасно, нужно либо использовать make, либо литерал мапы. Это создаст мапу в памяти, и вы сможете безопасно выполнять операции с элементами.

#### Инициализация с помощью make:
```go
package main

import "fmt"

func main() {
// Инициализация с помощью make
m := make(map[string]int)  // Инициализированная мапа

    m["apple"] = 5 // Безопасно добавляем элемент
    fmt.Println(m)  // Выводит: map[apple:5]
}
```
#### Инициализация с помощью литерала мапы:
```go
package main

import "fmt"

func main() {
// Инициализация с помощью литерала мапы
m := map[string]int{
"apple": 5,
"banana": 10,
}

    fmt.Println(m) // Выводит: map[apple:5 banana:10]
}
```
В обоих случаях мапа будет корректно инициализирована, и вы сможете безопасно работать с ней.

### 3. Особенности работы с мапами
1. Инициализированная мапа (с помощью make или литерала):
   - После инициализации мапы с помощью make, вы можете безопасно добавлять, удалять и изменять элементы. Мапа будет указывать на реальный объект хеш-таблицы в памяти.

2. Неинициализированная мапа (nil map):
   - Мапа в этом случае не указывает на память, и любые попытки записать в неё данные приведут к панике. Чтение значений из неинициализированной мапы не вызовет панику, но вернется нулевое значение для данного типа (например, для чисел это 0, для строк — пустая строка, для указателей — nil).

#### Пример чтения из неинициализированной мапы:
```go
package main

import "fmt"

func main() {
var m map[string]int // Неинициализированная мапа (nil)

    // Чтение из неинициализированной мапы
    // Это не приведет к панике, но вернет нулевое значение (0)
    fmt.Println(m["apple"]) // Выводит: 0

    // Проверка на наличие ключа
    value, exists := m["apple"]
    fmt.Println(value, exists) // Выводит: 0 false
}
```

## 4. Что происходит при записи в неинициализированную мапу?
Как уже упоминалось, попытка записать в неинициализированную мапу вызовет панику. Но что если нужно создавать мапу в поздний момент (например, внутри функции), но не инициализировать её сразу?

#### Решение:
всегда используйте make для инициализации мапы или создавайте её с помощью литерала в момент создания. Это обеспечит корректную работу с мапой, избегая паники.

## 5. Резюме: как работать с мапами в Go
### Неинициализированная мапа (nil):

Не может быть использована для добавления или изменения элементов.
Чтение элементов вернет значение по умолчанию для типа (например, 0 для чисел).
Попытка записи вызовет панику.
Инициализированная мапа:

С помощью make или литерала можно создать мапу, с которой можно безопасно работать.
Все операции записи, удаления и поиска выполняются корректно.

### Рекомендация:
Чтобы избежать паники и ошибок, всегда инициализируйте мапы перед их использованием:

```
go
m := make(map[string]int)  // Инициализированная мапа
m["apple"] = 5             // Безопасная запись
```

#### Или используйте литерал:
```
go
m := map[string]int{"apple": 5, "banana": 10}
```

#### Итак, основное правило: никогда не пытайтесь изменять или добавлять элементы в неинициализированную мапу.

---

### В Go нулевое значение для мапы — это nil. Это значит, что если мапа не была инициализирована, то она не указывает на реальный объект в памяти. Однако при чтении из неинициализированной мапы возвращается нулевое значение для типа значений (например, 0 для чисел, "" для строк и nil для указателей).

#### Основные моменты:
- Чтение из nil мапы не вызывает паники, но возвращает нулевое значение.
- Запись в nil мапу вызывает панику.
- При проверке наличия ключа в nil мапе результат будет false, а значение — нулевое для этого типа.

#### Пример:

```
go
var m map[string]int // nil map
fmt.Println(m["key"]) // 0 (нулевое значение для int)

m["key"] = 1 // panic: assignment to entry in nil map
```

---

## zero value
- Zero value: nil
- Мапы — это ссылочные типы, и их zero value — это nil, что означает отсутствие мапы, но можно безопасно проверять на наличие ключей.
  Пример:

```go
var m map[string]int
fmt.Println(m) // nil
```

---

## 2. Что такое Хеш-таблица?
   Хеш-таблица — это структура данных, которая используется для эффективного хранения пар "ключ-значение" с быстрым доступом к значениям по ключу  O(1)/константное.
### Хеш-таблица состоит из:
1. Хеш-функции
2. Бакетов (или массивов)
#### Принцип работы хеш-таблицы:
- Хеш-функция — это функция, которая принимает ключ и возвращает индекс (или хеш) в массиве (или таблице), где будет храниться соответствующее значение.
- Коллизии — случаются, когда два разных ключа хешируются в одинаковое значение. В хеш-таблицах с разрешением коллизий могут использоваться разные методы, такие как:
1. Цепочки (Chaining): Каждый элемент с одинаковым хешом хранится в списке (или другой структуре данных) в том же индексе.
2. Открытая адресация (Open Addressing): Если два ключа хешируются в один индекс, то поиск "пустого" места для второго элемента будет происходить в другом месте таблицы.
#### Пример работы хеш-таблицы:
- Применяется хеш-функция к ключу, чтобы получить индекс.
- Если в этом индексе уже есть элемент (коллизия), то решается, как с ней поступить (например, добавляется в цепочку или используется открытая адресация).
- При запросе значения по ключу снова используется хеш-функция для вычисления индекса и поиска значения.
- Пример хеш-таблицы в Go можно увидеть через тип map, который работает как хеш-таблица.

### Бакеты в мапах и когда происходит эвакуация
#### 1. Про бакеты в мапах:
- Бакеты — это массивы, в которых хранятся ключи и значения мапы. Каждый бакет содержит фиксированное количество пар ключ-значение.
- Хэш-функция определяет, в какой бакет попадет ключ.
- Если в бакете есть коллизии (несколько ключей с одинаковым хэшом), они хранятся в виде цепочек внутри бакета.

#### 2. Когда происходит эвакуация:
**Эвакуация** — это процесс перемещения данных из старых бакетов в новые. Она происходит во время **расширения (resize)** мапы:
- При эвакуации в новый бакет переносятся все элементы старого бакета, включая данные из основного бакета и его оверфлоу. Хэш-функция пересчитывается, и элементы распределяются по новому набору бакетов, так как их количество увеличилось.
- Принятие решения о выполнении эвакуации зависит от значения load factor, — это среднее заполнение бакетов. В Go значение loadFactor равно 6.5, — это означает, что процесс эвакуации начинается, когда средняя заполняемость бакетов достигает 6.5 или 80% для бакета с размером 8
#### Причина расширения:
- Если мапа достигает определенного коэффициента загрузки (например, слишком много элементов на бакет).
- В случае удаления большого количества элементов мапа также может уменьшиться.

#### Процесс эвакуации:
- При увеличении размера мапы количество бакетов удваивается.
- Данные из старых бакетов перераспределяются между новыми бакетами на основе нового хэш-функционирования.

#### При скольки элементов на бакет происходит эвакуация?

**Эвакуация** (перераспределение) бакетов в мапах Go происходит, когда **коэффициент загрузки** превышает определенный порог.

#### Конкретные числа:
1. Максимум 8 элементов на бакет:
- Если в одном бакете становится больше 8 элементов (включая ключи из основной структуры и оверфлоу-бакетов), запускается процесс увеличения числа бакетов.

2. Оверфлоу-бакеты:
- Если бакет переполняется (например, в результате коллизий), создаются дополнительные "оверфлоу-бакеты".
- Если общее количество элементов на один бакет, включая оверфлоу, превышает порог в 8 элементов, это сигнал для перераспределения.

#### Почему 8?
- Это значение выбрано как компромисс между производительностью и использованием памяти. Слишком большая загрузка бакета замедляет операции поиска, а слишком маленькая увеличивает затраты на память.
  Таким образом, если количество элементов на бакет превышает 8, мапа начинает процесс эвакуации и удваивает количество бакетов.

---

## 3. Что такое хеш-функция?
   Хеш-функция — это алгоритм, который преобразует входные данные (например, строку или число) в фиксированный размер, обычно целое число. Это число называется хешем, и оно используется для размещения данных в хеш-таблице.
   Хеш-функция использует High-order и Low-order биты для создания уникального хеша

### High-order биты (старшие биты хэша)
  - Используются для выбора группы/бакета.
  - То есть именно они определяют, куда попадёт ключ в хэш-таблице.

### Low-order биты (младшие биты хэша)
  - Используются внутри выбранной группы:
  - для хранения control byte (отличительный кусочек хэша),


#### В реальных хеш-таблицах обычно используются более сложные хеш-функции, такие как:
- SHA-256 (используется в криптографии),
- FNV-1a (быстрая и простая хеш-функция для строк),
- MurmurHash (популярная хеш-функция для хеш-таблиц).

#### Хеш-функции имеют несколько ключевых свойств:
- Детерминированность: Для одного и того же входного значения хеш-функция всегда должна возвращать одинаковый результат.
- Быстродействие: Хеш-функция должна работать быстро, особенно при большом количестве данных.
- Распределённость: Хеш-функция должна обеспечивать равномерное распределение хешей по всей таблице, чтобы минимизировать коллизии.


---

### Производительность:
Хеш-таблица в Go предоставляет среднее время выполнения операций:

#### Поиск: O(1) в среднем.
#### Вставка: O(1) в среднем.
#### Удаление: O(1) в среднем. Однако в случае частых коллизий или плохой хеш-функции время работы может увеличиться.
#### O(1) - Так же называется константное






# Map: Go ≤1.23 vs Go 1.24
### 🔹 Структура хранения
- Было: buckets по 8 элементов + связный список для коллизий.
- Стало: Swiss Table — группы по 8 элементов, control bytes, probing без указателей.

### 🔹 Поиск (lookup)
- Было: поиск по цепочке bucket’ов → кеш-промахи.
- Стало: SIMD-сравнение control-байтов (8 сразу), меньше сравнений ключей, меньше промахов.

### 🔹 Вставка
- Было: при переполнении bucket — новый bucket, цепочка растёт.
- Стало: probing по соседним группам, всё компактно, без цепочек.

### 🔹 Удаление
- Было: delete освобождал слот сразу.
- Стало: слот помечается как deleted (tombstone), позже чистится. → delete дороже.

### 🔹 Итерация
- Было: итерация проходила по связным спискам bucket’ов.
- Стало: итерация по группам с control-байтами, быстрее (до +60%).

### 🔹 Память
- Было: много указателей на цепочки, слабая кеш-локальность.
- Стало: ключи/значения рядом, compact layout → до ~30% экономии памяти.

### 🔹 Производительность
- Было: стабильный O(1), но lookup/итерация дорогие на длинных цепочках.
- Стало: стабильный O(1), быстрее lookup (+30%), быстрее iteration (+60%).

#### 📌 Вывод для собеса:
- В Go 1.24 map перешла на Swiss Table. Это убрало связные списки bucket’ов, добавило control bytes и probing. В итоге lookup и итерация стали быстрее, память используется эффективнее, но delete немного дороже. Для разработчика API не изменилось, но производительность выросла ощутимо.

# Глоссарий

#### 1) Probing по соседним группам, без цепочек
🔹 Что было до Go 1.24
- В старой реализации map каждая ячейка (bucket) вмещала до 8 элементов.
- Если bucket переполнялся, создавался новый bucket и «подвешивался» к старому через указатель (цепочка).

Получалось так:

```[bucket1] -> [bucket2] -> [bucket3] ...```

Когда искали ключ, нужно было пройти сначала первый bucket, потом по указателю в следующий, и так далее.

Это называется pointer chasing (прыжки по памяти).

- Минус: данные разрознены в памяти, кэш CPU неэффективен, много случайных промахов.

🔹 Что стало в Go 1.24
- Теперь используется схема linear probing: если в группе нет места или ключ не совпал → проверяем соседнюю группу в том же массиве.

Картина:

```[group1][group2][group3][group4] ...```

- Всё лежит в одном большом куске памяти, без указателей, без цепочек.
- Если коллизия — мы идём последовательно вправо по группам (1 → 2 → 3 …), пока не найдём слот.

Такой проход называется probing (проба).

- Линейный probing в Swiss Table даёт:
  - последовательный доступ (CPU prefetch работает);
  - меньше кеш-промахов;
  - упрощённая структура (нет лишних указателей и bucket’ов).

👉 Итог: вместо списка указателей в памяти мы имеем последовательный массив с шагом «соседние группы».

#### 2) Compact layout (ключи и значения рядом) → экономия памяти
- Раньше: ключи и значения хранились раздельно (ключи в bucket, значения в отдельном массиве), плюс указатели на цепочки. Это = разрозненный доступ к памяти.
- Сейчас: в Swiss Table ключ и значение кладутся рядом друг с другом в одной группе. Контрольные байты тоже рядом.

- Плюс:
  - меньше служебных структур → меньше overhead (экономия до 30% памяти);
  - доступ к ключу и значению идёт из одной кеш-линии.

#### 3) SIMD-сравнение control-байтов (8 сразу)
- Каждая группа хранит 8 control-байтов — маленькие «подписи» от хеша (обычно 7–8 бит).
- Когда мы ищем ключ, мы сначала проверяем только эти подписи.
- CPU может взять сразу 8 control-байтов и одним SIMD-инструкцией (memcmp, AVX2, SSE и т.д.) сравнить с подписью искомого ключа.
- Из 8 позиций обычно совпадет максимум 1–2, и только тогда мы сравниваем реальные ключи.

- Плюс:
  - резкое снижение числа сравнений «ключ на ключ»;
  - меньше случайных обращений к памяти (если control-байт не совпал — ключ точно другой).
  - В итоге lookup быстрее на десятки процентов.

#### Что это за control-байты
- У каждого ключа в map есть хеш.
- В Swiss Table этот хеш разбивается на 2 части:
  - h1 → указывает на стартовую группу;
  - h2 → хранится в control-байте (1 байт на слот).
- То есть в каждой группе лежит массив из 8 control-байтов, которые представляют «подписи» ключей.

#### 🔹 Как работает поиск
- Когда ищем ключ:
  - Берём его хеш → выделяем h1 и h2.
  - Смотрим в группу, на которую указывает h1.
  - Берём 8 control-байтов этой группы.
  - Сравниваем их сразу все 8 с h2.


### 1) Как создаются группы вместо бакетов.Как происходит эвакуация если она осталась. Что бывает с группами, если они заканчиваются и по сколько создаются -  Было/Стало

#### Было (до Go 1.24)

- Map состояла из массива bucket’ов.
- Каждый bucket = до 8 элементов (ключ+значение + служебные байты).
- Если bucket переполнялся → создавался overflow bucket (цепочка).
- Структура:

```[bucket] -> [overflow] -> [overflow] ...```

- Ключи/значения могли расползаться по памяти, кеш работал плохо.

#### Стало (Go 1.24)
- Вместо bucket’ов появились группы (groups).
- Каждая группа = 8 control-байтов + 8 слотов (ключ+значение).
- Все группы лежат подряд в одном большом массиве.
- При коллизии идём в соседнюю группу (linear probing), вместо создания цепочек.
```[group1][group2][group3]...```

👉 Группа ≈ бывший bucket, но:
- нет overflow-цепочек; 
- контроль идёт через control-байты;
- ключи и значения лежат рядом.


### 2) Эвакуация (grow/rehash)

Эвакуация не исчезла, но изменилась.

#### Было
- Когда количество элементов > load factor (около 6.5 на bucket), таблица удваивалась.
- Создавался новый массив bucket’ов, и все элементы постепенно эвакуировались (перемещались).
- Это делалось «лениво» — при операциях записи/чтения происходило перемещение части данных.

#### Стало
- Swiss Table также использует resize при достижении load factor (около 87.5% заполненности).
- Новый массив групп создаётся с удвоенным размером.
- Эвакуация идёт похожим ленивым способом — элементы переносятся при обращении.
- Отличие: теперь переносятся группами, а не bucket + цепочки.

### 3) Что если группы заканчиваются?
- Таблица изначально создаётся с количеством групп = степенью двойки (например, 8, 16, 32).
- При вставках проверяется load factor (~7 из 8 слотов в среднем).
- Если почти все группы забиты → создаётся новый массив групп в 2 раза больше.
- Старые группы начинают «эвакуироваться» в новый массив.

📌 Важно: групп не создаётся динамически по одной, они всегда выделяются сразу массивом, как и раньше с bucket’ами.