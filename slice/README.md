# Срез (slice) в Go — это динамическая **структура** данных, обеспечивающая удобную работу с массивами.
## Основные свойства:
### Определение:

Срез — это структура содержащая:
- Указатель на начало массива(pointer).
- Длину (len): количество элементов в срезе.
- Вместимость (capacity): максимальное число элементов, которые можно добавить без выделения новой памяти.
#### Создание:

```go 
slice := make([]int, length, capacity) // length - длина, capacity - емкость
```
### Динамический рост:

При добавлении элементов (append) срез может перерасти свою capacity. Тогда выделяется новый массив, а старые данные копируются.

**Алгоритм изменения capacity:**
```go
До 512 элементов: capacity удваивается.
Пример: 1 → 2 → 4 → 8 → 16 → 32 → 64 → 128 → 256 → 512.
Свыше 512 элементов: рост становится адаптивным, например:
512 → 848 (~65% прирост).
848 → 1280 (~51% прирост).
1280 → 1792 (~40% прирост).
```
### Преимущества:
- Гибкость: длина может увеличиваться или уменьшаться.
- Удобство: предоставляет богатый набор операций для работы с массивами.

### Важные моменты:
- Срезы делят один массив с другими срезами, что позволяет эффективно работать с памятью, но может приводить к нежелательным изменениям.

Если требуется независимый массив, используйте копирование:
```go
newSlice := append([]int{}, originalSlice...)
```
### Вывод:
Срезы — это мощный инструмент для работы с динамическими массивами в Go,
но нужно понимать их внутреннее устройство (ссылки на массив и механизм роста capacity), чтобы избегать неожиданных эффектов.

---

# 1. Как работает append
   ### Описание:
   Функция append добавляет элементы в конец слайса. Если емкости (capacity) слайса хватает, новые элементы записываются в существующий массив. Если емкости не хватает, создается новый массив с увеличенной емкостью, копируются существующие данные, и затем добавляются новые элементы.

#### Сигнатура:
```go
func append(slice []T, elems ...T) []T
```

- slice — исходный срез.
- elems — элементы, которые нужно добавить.
- Возвращает новый срез. Это может быть тот же самый срез (если емкости хватает) или новый (если емкости недостаточно).
#### Пример работы:
```go
package main

import "fmt"

func main() {
s := []int{1, 2, 3} // Срез с capacity = 3
fmt.Println("Before append:", s, "Len:", len(s), "Cap:", cap(s))

    s = append(s, 4, 5) // Добавляем элементы
    fmt.Println("After append:", s, "Len:", len(s), "Cap:", cap(s))
}
```

### Вывод:
```mathematica
Before append: [1 2 3] Len: 3 Cap: 3
After append: [1 2 3 4 5] Len: 5 Cap: 6
```
#### Что происходит:
- Добавление элементов: В срезе s изначально len=3, cap=3. При добавлении элементов (4, 5), емкости не хватает.
- Создание нового массива: Создается новый массив с увеличенной емкостью. В данном случае новая емкость = 6 (удваивание).
- Копирование: Старые элементы [1, 2, 3] копируются в новый массив.
- Добавление новых элементов: [4, 5] добавляются в конец.

### Особенности append:
#### Изменение capacity:
Удваивается, если емкость <= 512.
Увеличивается адаптивно (примерно на 25-50%), если емкость > 512.

#### Работа с nil-срезами:

```go
var s []int
s = append(s, 1, 2, 3)
fmt.Println(s) // [1 2 3]
```

Если исходный срез равен nil, функция append создаст новый массив.

#### Возвращаемое значение:
Всегда используйте результат append, так как старый срез может указывать на устаревшую память.

---

# 2. Как работает copy
   ### Описание:
   Функция copy копирует элементы из одного среза в другой. Возвращает количество скопированных элементов (это минимальное значение между длинами источника и приемника).

#### Сигнатура:
```go
func copy(dst, src []T) int
```

- dst — срез назначения (куда копируем).
- src — срез-источник (откуда копируем).
- 
#### Пример работы:
```go
package main

import "fmt"

func main() {
src := []int{1, 2, 3, 4}
dst := make([]int, 2) // Целевой срез длиной 2

    copied := copy(dst, src) // Копируем из src в dst
    fmt.Println("Source:", src)
    fmt.Println("Destination:", dst)
    fmt.Println("Copied elements:", copied)
}
```

#### Вывод:
```yaml
Source: [1 2 3 4]
Destination: [1 2]
Copied elements: 2
```

### Что происходит:
#### Минимум по длине:

Длина src = 4, длина dst = 2.
Копируется только min(len(src), len(dst)) элементов, то есть 2.

### Копирование:

Первые 2 элемента из src копируются в dst.
dst[0] = src[0], dst[1] = src[1].

#### Остатки:
Элементы src[2:] игнорируются, так как длина dst меньше.

#### Пример копирования в больший срез:
```go
package main

import "fmt"

func main() {
src := []int{1, 2, 3, 4}
dst := make([]int, 5) // Целевой срез длиной 5

    copied := copy(dst, src) // Копируем из src в dst
    fmt.Println("Source:", src)
    fmt.Println("Destination:", dst)
    fmt.Println("Copied elements:", copied)
}
```

### Вывод:
```yaml
Source: [1 2 3 4]
Destination: [1 2 3 4 0]
Copied elements: 4
```

### Особенности copy:
#### Не создает новых массивов:
Копирует данные из одного существующего массива в другой.

#### Порядок копирования:
Сначала элементы из src переносятся в dst. Остальные элементы dst остаются без изменений.

### Работа с nil-срезами:

```go
var src []int
dst := make([]int, 3)
copied := copy(dst, src)
fmt.Println("Copied elements:", copied) // 0
```
Если источник src равен nil, ничего не копируется.

#### Работа при совпадении источника и назначения:
Если dst и src пересекаются, результат зависит от порядка их перекрытия.

#### В слайс nil можно аппендить, но нельзя обратиться по индексу

### Функция append возвращает новый срез. Однако важно понять, что срез в Go — это структура, содержащая ссылку на массив, а не сами данные.
**Функция append всегда возвращает новый слайс**, который может указывать как на тот же массив (если емкость достаточна), так и на новый массив (если емкость превышена). Чтобы изменения отразились на слайсе, нужно сохранить результат вызова append.
#### Пример:

```go
func main() {
    sl := make([]int, 0, 3)

    sl = append(sl, 1, 2)
    addSl(sl)

    fmt.Println(sl)
}

func addSl(sl []int) {
    sl = append(sl, 3)
}
```
#### Почему изменения не видны в main:
- В функцию addSl передается копия слайса из main. Внутри функции добавляется новый элемент, и слайс sl теперь имеет длину 3, но это изменение происходит только внутри функции.
- В main слайс остаётся с длиной 2, так как append в addSl создает новый слайс, а изменения не сохраняются в оригинальной переменной sl из main.
- Даже если в main передать слайс с длиной 3 и емкостью 10, внутри addSl append создаст новый слайс с длиной 4, но в main изменений не будет, так как исходный слайс не был обновлен.

#### Обратная ситуация
Если мы поменяем в addSl первый элемент массива или второй, так как длина слайса в main в диапозоне длины слайса в addSl, мы увидим в main изменения
так как поменяли 1 либо 2 элемент массива. Но если мы выйдем за пределы capacity, то в addSl создастса уже новый массив и слайс будет ссылаться на новый массив
```go
func addSl(sl []int) {
    sl[0] = 10 // Изменяем первый элемент
}
```
---

### zero value
- Zero value: nil
- Слайс — это ссылочный тип. По умолчанию он равен nil, что означает отсутствие выделенной памяти.

#### Пример:
```go
var s []int
fmt.Println(s) // nil
```

---

### Какое zero value будет у слайса после объявления так?
```go
sl1 := []int{}
	
var sl2 []int

sl3 := make([]int, 0)
```
1. sl1 := []int{}
   - Здесь создается пустой слайс с нулевой длиной и емкостью.
   - Значение sl1 — это инициализированный слайс, то есть он уже имеет выделенную память, но не содержит элементов.
   - Проверка: sl1 == nil даст false.
2. var sl2 []int
   - Здесь создается неинициализированный слайс (его значение nil).
   - У него нет выделенной памяти, длина и емкость равны 0.
   - Проверка: sl2 == nil даст true.
3. sl3 := make([]int, 0)
   - Этот слайс создается с использованием функции make, которая явно выделяет память, но с длиной 0.
   - Значение sl3 — это инициализированный слайс с длиной 0 и емкостью 0.
   - Проверка: sl3 == nil даст false.

#### Сравнение слайсов

| Слайс | Длина (`len`) | Емкость (`cap`) | Значение `nil` |
|-------|---------------|-----------------|----------------|
| `sl1` | 0             | 0               | false          |
| `sl2` | 0             | 0               | true           |
| `sl3` | 0             | 0               | false          |

### Итог
Все три слайса имеют нулевую длину и емкость, но только sl2 является nil. Разница в том, как выделяется память и как слайс инициализируется.