# Строки в Go

Для представления строк в Go поддерживается тип данных string. Строка Go — это просто массив байт. Исходя из этого, если применим функцию len() к строке, то получим количество байт. В одном байте может храниться любой символ ASCII, однако для хранения одного символа Unicode обычно требуется несколько байтов. В общем, чтобы посчитать именно количество символов, необходимо преобразовать строку в тип rune. Еще одним способом определения длины строки является функция RuneCountInString пакета utf8.

Вообще, руна (тип данных rune) — это значение int32, которое используется для представления одного кодового пункта Unicode. Руна представляет собой целое значение и используется для представления отдельных символов Unicode или, реже, для предоставления информации о форматировании.

#### Объявление и инициализация руны:

```go
var r rune = 'A'
```

### Преобразование строки в срез рун:

```go
s := "Привет"
runes := []rune(s)
```
### Итерация по рунам в строке:
```go
for _, r := range "Привет" {
	fmt.Printf("%c ", r)
}
// П р и в е т
```
### Обратное преобразование среза рун в строку:

```go
runes := []rune{'П', 'р', 'и', 'в', 'е', 'т'}
s := string(runes)  // "Привет"
```

### Получение Unicode-кода руны:

```go
r := 'A'
code := int32(r)  // 65
```

### Проверка длины строки в рунах:

```go
s := "Привет"
length := utf8.RuneCountInString(s)  // 6
```

### Строка "hello, world" и 2 её подстроки:

---

# Как эффективно конкатенировать множество строк
Строки в Go можно складывать (конкатенировать). Для многих операций есть стандартные пакеты, к примеру strings, fmt. В целом, есть 2 основных варианта конкатенации, но один из них в некоторых условиях может быть очень неэффективным.

### Напишем код с функцией concat, которая объединяет все строковые элементы среза с помощью оператора +=:

```go
func concat(values []string) string {
    s := ""
    for _, value := range values {
        s += value
    }
    return s
}
```
В этой реализации мы забываем базовую характеристику строки: ее неизменность. Следовательно, с каждой итерацией s не обновляется, вместо этого в памяти создается новая строка, что сильно влияет на время выполнения этой функции.

### Благо есть пакет strings и структура Builder, чуть переделаем нашу функцию concat:

```go
func concat(values []string) string {
    sb := strings.Builder{} // создается strings.Builder
    for _, value := range values {
        _, _ = sb.WriteString(value) // добавляется строка
    }
    return sb.String() // возвращается результирующая строка
}
```
### А теперь напишем другую реализацию concat, используя Grow из strings.Builder:
```go
func concat(values []string) string {
    total := 0
    for i := 0; i < len(values); i++ { // проводятся итерации по каждой строке для вычисления общего числа байтов
        total += len(values[i])
    }
    sb := strings.Builder{}
    sb.Grow(total) // вызывается Grow с аргументом, равным этому общему числу
    for _, value := range values {
        _, _ = sb.WriteString(value)
    }
    return sb.String()
}
```

#### Перед началом итераций мы вычисляем общее количество байтов, которое будет содержать окончательная строка, и присваиваем это значение переменной total. Обратите внимание, что нас интересует не количество рун, а количество байтов, поэтому мы используем функцию len. Затем мы вызываем Grow, чтобы гарантировать наличие места для байтов total, прежде чем проводить итерации по строкам.

Запустим бенчмарк для 3 версий нашей функции concat (v1 с использованием +=, v2 с использованием strings.Builder{} без предварительного резервирования места в памяти и v3 с использованием strings.Builder{} с предварительным резервированием). Входной срез содержит 1000 строк, и каждая строка содержит 1000 байт:

- BenchmarkConcatV1-4 16 72291485 ns/op
- BenchmarkConcatV2-4 1188 878962 ns/op
- BenchmarkConcatV3-4 5922 190340 ns/op
- Как видим, последний способ самый эффективный.
#### Почему двукратное итерирование по входному срезу может ускорить код? Дело в том, что если для среза с заданной длиной или емкостью не выделено место заранее, то этот срез будет продолжать расти каждый раз, когда окажется заполненным, что приведет к дополнительным выделениям памяти и копиям.

strings.Builder — рекомендуемое решение для конкатенации списка строк. Обычно это решение следует использовать в циклах.

Если просто нужно объединить несколько строк, использование strings.Builder не рекомендуется, так как это сделает код менее читаемым, чем использование оператора += или fmt.Sprintf.

Классная книга по теме: «100 ошибок Go и как их избежать» — Тейва Харшани