package Строки

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

func MainString() {

	/* Вариант 1 - не эффективный

	str := ""

	for i := 0; i < 100_000; i++ {
		str += fmt.Sprintf("%d", i)
	} */

	// Вариант 2 - эффективный

	builder := strings.Builder{}
	start := time.Now()
	for i := 0; i < 100_00; i++ {
		strID := strconv.Itoa(i)
		builder.WriteString(strID)
	}
	fmt.Println(time.Since(start))
}

/*
	Так как строка иммутабельна(не изменяемая), то при конкотенации строк каждый раз пересоздается строка.
	В данном случае
	```
		str := ""
		for i := 0; i < 100_000; i++ {
			str += fmt.Sprintf("%d", i)
		}
	```
	Строка будет пересоздаваться 100_000 раз, что сильно перенагружает память на ровном месте и может привести
	к утечке памяти.

	Лучше для случаев, когда нужно сконкотенировать большое колличество итераций использовать встроенный пакет go
	strings метод Builder{}. Он при конкотенации будет записывать в свой буфер значения и единожды сконкотенирует их
	когда мы вызовем res := str.String() для получения результата. Это улучшает производительность.

	Так же для производительности перевода из целочисленного значения в строку, лучше использовать strconv.Itoa,
	так как под капотом у fmt.Sprintf("%d", i) используется рефлексия для определения типа данных у i


	Все эти оптимизации позволяют в разы уменьшить время подсчета. Можно засечь время перед началом подсчета таким образом
	с разными вариантами склеивания строки
	```
		builder := strings.Builder{}

		start := time.Now()
		for i := 0; i < 100_00; i++ {
			strID := strconv.Itoa(i)
			builder.WriteString(strID)
		}
		fmt.Println(time.Since(start))
	```


	ВАЖНО!
	Если нужно сконкотенировать строку маленькое колличество раз условно раз 10,
	то для большей читаемости и простоты кода лучше использовать стандартную конкотенацию через знак сложения "+".
	Это быстрее и проще для читаемости. На память никаких нагрузок не будет и утечек памяти тоже.
*/
